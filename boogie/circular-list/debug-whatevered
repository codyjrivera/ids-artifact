    // havoc Br, alloc, C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr;
    // havoc cur, cur_next;
    // assume cur != null;
    //     assume cur_next == C.next[cur];
    //     assume cur != x ==> (
    //         RefSetsEqual(Br, EmptyRefSet[cur := true])
    //         && LC_Trans_NoRlen(C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr, cur)
    //         && C.last[cur] == x
    //         && C.len[cur] > 0
    //     );
    //     assume cur == x ==> (
    //         LC(C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr, cur)
    //         && C.last[cur] == x
    //     );
    //     assume Unchanged(
    //         C.k, C.next, C.prev,
    //         C.last, C.len, C.rlen, 
    //         C.keys, C.repr, 
    //         C.k_pl1, C.next_pl1, C.prev_pl1,
    //         C.last_pl1, C.len_pl1, C.rlen_pl1, 
    //         C.keys_pl1, C.repr_pl1,
    //         x
    //     );
    //     assume RefSetSubset(Br, EmptyRefSet[cur := true]);
    //     assume Frame_all(
    //         C.k, C.next, C.prev,
    //         C.last, C.len, C.rlen, 
    //         C.keys, C.repr,
    //         old(C.k), old(C.next), old(C.prev),
    //         old(C.last), old(C.len), old(C.rlen), 
    //         old(C.keys), old(C.repr),
    //         old(C.repr)[old(C.last)[x]], 
    //         old(alloc)
    //     );
    // assume cur != x;

    // // Do we have a valid termination measure?
    //     call t := Get_len(cur);
    //     assert t >= 0;
    //     z := t;

    //     call IfNotBr_ThenLC(cur_next);
    //     call cur_prev := Get_prev(cur);
    //     call IfNotBr_ThenLC(cur_prev);
    //     call cur_prev_rlen := Get_rlen(cur_prev);
    //     call Set_rlen(cur, cur_prev_rlen + 1);

    //     assert LC_Debug(C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr, cur);
    //     call AssertLCAndRemove(cur);
    //     cur := cur_next;
    //     call cur_next := Get_next(cur);
    //     call IfNotBr_ThenLC(cur_next);

    //     // Has our termination measure decreased?
    //     call t := Get_len(cur);
    //     assert t < z;


    // assert cur != null;
    //     assert cur_next == C.next[cur];
    //     assert cur != x ==> (
    //     //RefSetsEqual(Br, EmptyRefSet[cur := true])
    //       LC_Trans_NoRlen(C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr, cur)
    //          && C.last[cur] == x
    //          && C.len[cur] > 0
    //     );
    //     assert cur == x ==> (
    //         LC(C.k, C.next, C.prev,
    //             C.last, C.len, C.rlen, 
    //             C.keys, C.repr, cur)
    //         && C.last[cur] == x
    //     );
    //     assert Unchanged(
    //         C.k, C.next, C.prev,
    //         C.last, C.len, C.rlen, 
    //         C.keys, C.repr, 
    //         C.k_pl1, C.next_pl1, C.prev_pl1,
    //         C.last_pl1, C.len_pl1, C.rlen_pl1, 
    //         C.keys_pl1, C.repr_pl1,
    //         x
    //     );
    //     //assert RefSetSubset(Br, EmptyRefSet[cur := true]);
    //     assert Frame_all(
    //         C.k, C.next, C.prev,
    //         C.last, C.len, C.rlen, 
    //         C.keys, C.repr,
    //         old(C.k), old(C.next), old(C.prev),
    //         old(C.last), old(C.len), old(C.rlen), 
    //         old(C.keys), old(C.repr),
    //         old(C.repr)[old(C.last)[x]], 
    //         old(alloc)
    //     );
    //assume false;